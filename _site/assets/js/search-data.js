var store = [{
        "title": "Anyhow v1.2.0 Migration to rust_core",
        "excerpt":"Anyhow v1.2.0: Migration to rust_core package: anyhow anyhow’s Result type was migrated into rust_core. Anyhow remains completely standalone, only re-exporting the Result Type from rust_core, but gains compatibility with the rest of the rust_core ecosystem. In addition to the newly compatible types and extensions, such as Option and the cell library, the Result type got a big upgrade. There will likely be a separate post explaining more when rust_core is officially announced. But the big news I want to mention is the Result type now supports Early Return Key Notation which is a derivative of “Do Notation”. 1234567891011121314151617181920212223void main(){    usingTheEarlyReturnKey();    usingRegularPatternMatching();}Result&lt;int,String&gt; usingTheEarlyReturnKey() =&gt; Result(($){ // Early Return Key    // Will return here with 'Err(\"error\")'    int x = willAlwaysReturnErr()[$].toInt();    return Ok(x);});Result&lt;int,String&gt; usingRegularPatternMatching(){    int x;    switch(willAlwaysReturnErr()){    case Err(:final err):        return Err(err);    case Ok(:final ok):        x = ok.toInt();    }    return Ok(x);}Result&lt;double,String&gt; willAlwaysReturnErr() =&gt; Err(\"error\");Enjoy! ","categories": ["technical"],
        "tags": ["dart"],
        "url": "http://localhost:4000/posts/anyhow-1-2-0-migration-to-rust-core/"
      },{
        "title": "Announcing `rust_core`",
        "excerpt":"Announcing Rust Core in Dart: Program in Dart Like You Would in Rust For Rust developers involved in programming with Dart, or Dart developers interested in idiomatic and safe programming, we have developed “rust_core,” a package designed to implement Rust’s core library in Dart. Result, Option, Cell, OnceCell, LazyCell, etc. Are all done, along with nearly 200 extension methods for different scenarios, such as Future&lt;Result&lt;S,F&gt;&gt;, Result&lt;Option&lt;S&gt;,F&gt;, Result&lt;S?,F&gt;, etc. just to name a few. Pub: https://pub.dev/packages/rust_core Github: https://github.com/mcmah309/rust_core A link you might also be interest in Dart Equivalent To The Rust “?” Early Return Operator ","categories": ["technical"],
        "tags": ["dart","rust"],
        "url": "http://localhost:4000/posts/announcing-rust-core/"
      },{
        "title": "Announcing `activate`",
        "excerpt":"Announcing activate: A sane way to manage environment configuration Recently I got sick of the way I had different imperative ways of managing environments across language domains and having to re-configure things locally to replicate QA bugs, plus the hassle of working in a monorepo. I am also a big fan of tools like direnv and that inspired me to create activate. Activate allows you to switch an entire repo/monorepo between environments and reload environment changes with a single command. Example Use Cases   You have assets, data files, executables, or program files that should be used in different environments like Dev, QA, etc. e.g.    12345 [dev.links] \"app/data\" = \"path/to/dev/data\" [qa.links] \"app/data\" = \"path/to/qa/data\"        app/data is created and symlinked to the file or directory of the active environment.     You want different environment variables in each environment e.g.    1234567 [dev.env] HOST = \"localhost\" PORT = 3000 [qa.env] HOST = \"178.32.44.2\" PORT = 443        To load into your current shell run (this will also unload any activate environment).     1 eval \"$(activate -e &lt;name&gt;)\"`        Alternatively you can load the active .env file yourself or from an application, located at .activate/.env. This can also be useful for dev containers. Just add \"runArgs\": [\"--env-file\",\".activate/.env\"] to your .devcontainer/devcontainer.json file.     You are using a mono-repo and want to switch everything to a certain environment. Run:    1 activate -r &lt;name&gt;        any directory/subdirecory (respecting .gitignore) with an activate.toml file is switched to &lt;name&gt;   I hope this helps you too, more to come :) ","categories": ["technical"],
        "tags": ["rust"],
        "url": "http://localhost:4000/posts/announcing-activate/"
      },{
        "title": "`rust_core` 0.4 Release and Project Update",
        "excerpt":"rust_core 0.4 Release and Project Update github: https://github.com/mcmah309/rust_corepub: https://pub.dev/packages/rust_core Background rust_core is an implementation of the Rust’s core library in Dart. The goal is to bring Rust’s features and ergonomics toDart. This also provides a seamless developer experience for any developer using both languages. 0.4 Option A lot of possibilities opened up with Dart 3.3.0 release. Zero cost abstraction with extension types is a powerful tool. Thus, we migratedthe Option class to an extension type. Since exclusive nullable type extensions are not possible, Option fills this gapwith zero allocation runtime cost and chaining null aware operations. 1234    Option&lt;int&gt; intOptionFunc() =&gt; const None();    double halfVal(int val) =&gt; val/2;    Option&lt;double&gt; val = intOptionFunc().map(halfVal);    expect(val.unwrapOr(2.0), 2.0);Considering Option also supports early return key notation. 1234567    Option&lt;int&gt; intNone() =&gt; const None();    Option&lt;double&gt; earlyReturn(int val) =&gt; Option(($) { // Early Return Key      // Returns here, no need to do a `if null return`      double x = intNone()[$].toDouble();      return Some(val + x);    });    expect(earlyReturn(2), const None());And transitioning between is ergonomic 1234    Option&lt;int&gt; option = intNone();    int? nullable = option.v;    nullable = option.toNullable(); // or    option = nullable.toOption();Option seems like the go to when compared to using nullable directly when developing api’s or a least a solid companion. Slice and Iter Included in 0.4 are two new libraries slice and iter being developed but with the usual full test coverage guarantee of rust_core. A Slice is a contiguous sequence of elements in a [List]. Slices are a view into a list without allocating and copying to a new list,thus slices are more efficient than creating a sublist, but they do not own their own data. That means shrinking the original list can cause the slice’s range to become invalid, which may cause an exception. Slice also have a lot of efficient methods for in-place mutation within and between slices. e.g. 12345678    var list = [1, 2, 3, 4, 5];    var slice = Slice(list, 1, 4);    expect(slice, [2, 3, 4]);    var taken = slice.takeLast();    expect(taken, 4);    expect(slice, [2, 3]);    slice[1] = 10;    expect(list, [1, 2, 10, 4, 5]);A Dart Iterable is analogous to a Rust Iterator. Since Dart already has an Iterator class, to avoid confusion,the Dart implementation of the Rust iterator is RIterator. RIterator is a zero cost extension type of Iterable. RIteratormakes working with collections of rust_core types and regular Dart types a breeze. e.g. 12345678    var list = [1, 2, 3, 4, 5];    var filtered = list.iter().filterMap((e) {      if (e % 2 == 0) {        return Some(e * 2);      }      return None();    });    expect(filtered, [4, 8]);Misc Various additional extension methods were added. Future rust_core for being in pre-release is stable with about 400 tests and currently used in major applications under development internally. 0.4 May be the lastminor release before 1.0.0 but there also may be a 0.5.0 release. Two new packages are under development [rewind] and rust_std.   rewind Log exactly what you want, while being aware of [anyhow] types.  rust_std An implementation of Rust’s standard library in Dart.","categories": ["technical"],
        "tags": ["dart","rust"],
        "url": "http://localhost:4000/posts/rust-core-0-4-0/"
      },{
        "title": "Introducing `error_set`",
        "excerpt":"Introducing error_set: A Zig-Inspired Approach to Error Handling in Rust Github: https://github.com/mcmah309/error_set Following a recent discussion on reimagining Rust, many voiced the need for more terse error handling. While anyhow and thiserror serve their purposes, each comes with its trade-offs. This got me thinking: Is there a middle ground that combines flexibility with precision? Enter error_set a concept derived from Zig that elegantly balances the definition of possible errors within a given scope while remaining succinct and developer-friendly. Here’s a sneak peek of how it looks: 12345678910111213141516171819202122error_set! {    MediaError = {        IoError(std::io::Error)    } || BookParsingError || DownloadError || ParseUploadError;    BookParsingError = {        MissingBookDescription,        CouldNotReadBook(std::io::Error),    } || BookSectionParsingError;    BookSectionParsingError = {        MissingName,        NoContents,    };    DownloadError = {        InvalidUrl,        CouldNotSaveBook(std::io::Error),    };    ParseUploadError = {        MaximumUploadSizeReached,        TimedOut,        AuthenticationFailed,    };}With error_set, we no longer need “god enums” that are used in scopes where some variants can never happen. Instead we can tersely define the errors in scope and coerce them into a superset if propagated up the call stack. ","categories": ["technical"],
        "tags": ["rust"],
        "url": "http://localhost:4000/posts/introducing-error-set/"
      },{
        "title": "Introducing `indices`",
        "excerpt":"Introducing indices: Macros and Methods For Safely Retrieving Multiple Mutable Indices Of A Mutable Slice Github: https://github.com/mcmah309/indices indices is a crate with zero allocation macros and methods for retrieving multiple mutable indices from a mutable slice safely. 1let (two, four) = indices!(slice, 2, 4);Getting multiple mutable indices can be tricky due to the language’s strict borrowing rules.previously if you wanted to get multiple multiple indices of a slice you could use split_at_mut 12345678910let mut data = [1, 2, 3, 4, 5];let index1 = 2;let index2 = 4;let (first_part, second_part) = data.split_at_mut(index1 + 1);let len = first_part.len();let two = &amp;mut first_part[len - 1];let (_first_part, second_part2) = second_part.split_at_mut(index2 - len);let four = &amp;mut second_part2[0];println!(\"{}\", two); // 3println!(\"{}\", four); // 5Although slightly more verbose, this is fine until there is more than the index and values are only known at runtime (especially if ordering may also be unknown). Macros All macros are zero allocation and allow retrieving a variable number of indices at runtime. Prefer macros when the numberof indices are known at compile time. 123456789101112131415161718192021222324fn main() {    struct Person {        first: String,        last: String,    }    let mut data = [        Person { first: \"John\".to_string(), last: \"Doe\".to_string() },        Person { first: \"Jane\".to_string(), last: \"Smith\".to_string() },        Person { first: \"Alice\".to_string(), last: \"Johnson\".to_string() },        Person { first: \"Bob\".to_string(), last: \"Brown\".to_string() },        Person { first: \"Charlie\".to_string(), last: \"White\".to_string() },    ];    fn modify(data_slice: &amp;mut [Person], index: usize){        let (four, func_provided, three) = indices!(data_slice, 4, index, 3);        four.last = \"Black\".to_string();        func_provided.first = \"Jack\".to_string();        three.last = \"Jones\".to_string();    }    let slice = data.as_mut_slice();    modify(slice, 1);    assert_eq!(data[4].last, \"Black\");    assert_eq!(data[1].first, \"Jack\");    assert_eq!(data[3].last, \"Jones\");}Methods Methods allow for more dynamic runtime retrieval when the number of indices is unknown at compile time. e.g. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566fn main() {    struct Node {        index: usize,        visted: usize,        edges: Vec&lt;usize&gt;,        message: String,    }    let mut graph = vec![        Node {            index: 0,            visted: usize::MAX,            edges: vec![1, 2],            message: String::new(),        },        Node {            index: 1,            visted: usize::MAX,            edges: vec![0, 2],            message: String::new(),        },        Node {            index: 2,            visted: usize::MAX,            edges: vec![3],            message: String::new(),        },        Node {            index: 4,            visted: usize::MAX,            edges: vec![1],            message: String::new(),        },    ];    fn traverse_graph(graph: &amp;mut [Node], current: usize, start: usize) -&gt; bool {        if current == start {            return true;        }        let edges = graph[current].edges.clone();        let [mut current_node, mut edge_nodes] = indices_slices(graph, [&amp;[current], &amp;edges]);        for edge_node in edge_nodes.iter_mut() {            current_node[0].visted = current;            edge_node.message.push_str(&amp;format!(                \"This is Node `{}` Came from Node `{}`.\",                edge_node.index, current_node[0].visted            ));        }        for edge in edges {            if traverse_graph(graph, edge, start) {                return true;            }        }        return false;    }    traverse_graph(&amp;mut *graph, 2, 0);    let answers = [        \"This is Node `0` Came from Node `1`.\",        \"This is Node `1` Came from Node `3`.\",        \"This is Node `2` Came from Node `1`.\",        \"This is Node `4` Came from Node `2`.\",    ];    for (index, node) in graph.iter().enumerate() {        assert_eq!(&amp;node.message, answers[index]);    }}Enjoy! ","categories": ["technical"],
        "tags": ["rust"],
        "url": "http://localhost:4000/posts/introducing-indices/"
      },{
        "title": "Package Highlight - `dart_mappable`",
        "excerpt":"Package Highlight: dart_mappable https://pub.dev/packages/dart_mappable Many developers are familiar with the freezed package, but fewer have heard of dart_mappable. Both packages aim to bring data classes to Dart, but dart_mappable makes a few tradeoffs to offer significant benefits in return. From the documentation:   dart_mappable covers all basic features (from/to json, == override, hashCode, toString(), copyWith) while adding new or improved support for advanced use-cases including generics, inheritance and polymorphism, customization, and more. Additionally, it requires far less boilerplate. Let’s see it in action: dart_mappable 12345678part 'model.mapper.dart';@MappableClass()class MyClass with MyClassMappable {  final int myValue;  MyClass({required this.myValue});}vs freezed 123456789101112part 'model.freezed.dart';part 'model.g.dart';@freezedclass MyClass with _$MyClass {  @JsonSerializable(explicitToJson: true)  factory DocumentInfoLocalData({    required final int myValue,  }) = _MyClass;  factory MyClass.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$MyClassFromJson(json);}Benefits Boilerplate With dart_mappable the code is a lot more concise and forgiving to Dart developers. It’s difficult to make a syntactic error with dart_mappable - just add @MappableClass() and with &lt;class_name&gt;Mappable. While with freezed, it is pretty easy to mess up all the syntactic nuances required final .., @Default(...) final .., _$, _, _$..FromJson, @JsonSerializable(explicitToJson: true), factory, etc. With dart_mappable you just write dart code and it takes care of the rest. Custom Constructors and Flexibility Conciseness is great, but functionality is also important. With dart_mappable, you are not restricted to a freezed-like constructor; you can use any Dart constructor you prefer: 12345678MyClass(this.myValue);const MyClass(this.myValue);MyClass(this.myValue, [this.otherValue = 1]);MyClass(this.myValue, {this.otherValue}): assert(myValue &gt; 0); // not `@Assert('...')` neededMyClass(this.myValue) {    date = DateTime.now(); // Non-const default values :)    // other logic}Generics and Inheritance Dealing with generics is easy, since only regular dart code is needed, there’s no need to use additional annotations like @With or @Implements. Drawbacks Since you do not declare a fromJson constructor with dart_mappable it generates one for you, following the &lt;class_name&gt;Mapperconvention. 1MyClassMapper.fromJson(json);This is really a style preference since with freezed you have to reference the class anyways (MyClass.fromJson(json)).This may become more useful if the lanugage team ever decides to support abstract static methods. Another difference that some may consider a benefit or drawback is freezed tries to force immutability (unless you use @unfreezed).While dart_mapper leaves that it up to the user. Personally I always lean towards more power to the developer. Conclusion At the end of the day, dart_mappable gives Dart developers all the capabilities they usually choose freezed for, without getting in their way. Looking ahead, both of these approaches might become obsolete when static metaprogramming lands in early 2025. ","categories": ["technical"],
        "tags": ["dart"],
        "url": "http://localhost:4000/posts/package-highlight-dart-mappable/"
      },{
        "title": "The `Result` Type In Dart",
        "excerpt":"The Result Type In Dart Every modern programming language has error handling. Like Python, Dart chose the unchecked try-catch catch pattern, Java went with checked try-catch pattern, Zig went with Error Unions, and Rust went the Result type. What Is a Result Monad Type And Why Use it? Result is often referred to as a “monad”. A monad is just a wrapper around an object that provides a standard way of interacting with the inner object. TheResult monad is used in place of throwing exceptions. Instead, the functionreturns a Result, which can either be a Ok (Success) or Err (Error/Failure), Result is the sum type of the two. Using Result provides a predictable control flow to a program. Error handling is explicit as the caller of a functionthat returns an error must handle the possibility of an error at that point. At which the point, the calling function can resolveany possible issue or clean its state, where necessary, or pass the error up the chain until a function resolvesthe issue. The Problem With Dart Error Handling The best way to illustrate the problem with Dart’s error handling is an example. Consider the following program,which doesn’t do anything useful, but we are more interested in the control flow: 12345678910111213141516171819202122232425void main() {  // try {    print(order(\"Bob\", 1));  // } catch(e) {    // print(e);  // }}String order(String user, int orderNumber) {  final result = makeFood(orderNumber);  return \"Order of $result is complete for $user\";}String makeFood(int orderNumber) {  return switch(orderNumber) {    1 =&gt; makeHamburger(),    2 =&gt; makePasta(),    // Who catches this??    // How do we know we won't forget to catch this??    _ =&gt; throw Exception(\"Unknown order number '$orderNumber'.\"),  };}String makeHamburger() =&gt; \"Hamburger\";String makePasta() =&gt; \"Pasta\";There are several issues with this program:   If we forget to catch in the correct spot, we just introduced a bug or worse - crashed our entire program.  We may later reuse makeFood or order, and forget that it can throw.  The more we reuse functions that can throw, the less maintainable and error-prone our program becomes.  Throwing is also an expensive operation, as it requires stack unwinding.Result Type Throughout the rest of this article we will be looking at the Result type in Dart as provided by the rust_corepackage. Here is the previous example implemented with Result: 123456789101112131415161718192021222324import 'package:rust_core/result.dart';void main() {  print(order(\"Bob\", 1));}Result&lt;String, Exception&gt; order(String user, int orderNumber) {  final result = makeFood(orderNumber);  if(result case Ok(:final ok)) { // Could also use \"if(result.isOk())\" or a switch statement    return Ok(\"Order of $ok is complete for $user\");  }  return result;}Result&lt;String, Exception&gt; makeFood(int orderNumber) {  return switch(orderNumber) {    1 =&gt; Ok(makeHamburger()),    2 =&gt; Ok(makePasta()),    _ =&gt; Err(Exception(\"Unknown order number '$orderNumber'.\")),  };}String makeHamburger() =&gt; \"Hamburger\";String makePasta() =&gt; \"Pasta\";By using Result, we have removed all undefined behaviors due to control flow! Thus eliminatingall previously mentioned issues. You can interact with Result through conventions likecase Ok(:final ok) and isOk(), or methods like .map(..), .andThen(..), etc. Checking allows you toeither resolve any potential issues in the calling function or pass the error up the chain until a function resolvesthe issue. This provides predictable control flow to your program, eliminating many potential bugs and countlesshours of debugging. Conclusion In conclusion, adopting the Result type for error handling in Dart brings numerous benefits, especially in creatingpredictable and maintainable control flows. Unlike traditional try-catch mechanisms, Result ensures that errorhandling is explicit and unavoidable. Thus preventing potential bugs and improving code reliability.The rust_core package’s implementationof Result in Dart provides a powerful tool for managing errors effectively, aligning Dart’s error handling capabilities with those of more modern and robust systems like Rust.Embracing this approach will not only enhance the stability of Dart applications but also streamline the development process, making it easier to maintain and debug code in the long run. ","categories": ["technical"],
        "tags": ["dart"],
        "url": "http://localhost:4000/posts/the-result-type-in-dart/"
      },{
        "title": "Should You Really Ever Use ArrayVec or SmallVec or TinyVec As Your Go To Vec?",
        "excerpt":"Should You Really Ever Use ArrayVec or SmallVec or TinyVec As Your Go To Vec? Definitions ArrayVec: This is a vector-like structure with a fixed maximum capacity. Unlike a regular array, its actual size can change dynamically at runtime, accommodating a variable number of elements up to its capacity. The memory for elements is initialized upon insertion. This makes ArrayVec suitable for situations where you need more flexibility than a regular array but with a predictable, fixed maximum size. SmallVec: SmallVec acts like a vector, storing its items on the stack up to a predefined limit. If this limit is exceeded, it transitions to heap storage. This design is ideal when you have a “soft” upper size limit - cases where the collection rarely exceeds a certain size, but you want to avoid program failure if it does. It’s less optimal than a regular array or a Vec when used by itself outside this scenario. TinyVec: This is a hybrid of ArrayVec and a heap-allocated Vec. Like SmallVec, it transitions from stack to heap storage when a limit is exceeded. However, TinyVec is distinct in that it avoids using “unsafe” code, potentially increasing safety. A limitation is that types stored in TinyVec must implement the Default trait. Discussion For all these “vector on the stack” types, careful consideration is crucial. Generally, they should be used for small collections (significantly less than the 1-2 MB typical stack size limit) to prevent stack overflow. Additionally, while these structures can be returned from functions, this actually mightmake these structures less performant. This is because compiler optimizations may invoke a “stack copy” when returning the value or passing the value to a function. Therefore, these should be primarily used within a single function’s scope and avoided in scenarios where large or unpredictable sizes are expected. Also each of these structures now have an extra branch (e.g. .is_on_stack()) for operations such as .push(). That said, the primary optimization to be made for vectors is not actually keeping them on the stack, it is avoiding re-allocations.The better strategy is to simply reuse a regular Vec between invocations - create it once, then use it, call .clear() on it and repeat. That way you get no additional allocations and no overhead on .push() or passing it around. The real use case for SmallVec and such is making a collection of them, such as Vec&lt;SmallVec&gt; (or more realistically BTreeSet&lt;MyStruct&gt; where MyStruct contains a SmallVec inside) to optimize for cache locality. Loads from RAM are slow compared to the speed of the CPU, so putting the data closer together minimizes the amount of loads. Conclusion Using any of these types is likely a premature optimization and the standard Vec should usually be preferred, unless the code is performance critical and previously mentioned bounds hold. ","categories": ["technical"],
        "tags": ["rust"],
        "url": "http://localhost:4000/posts/ArrayVec-or-SmallVec-or-TinyVec/"
      }]
